from Crypto.Util.number import isPrime, bytes_to_long, inverse, long_to_bytes
import random
import os

def getWYSIprime():
    while True:
        digits = [random.choice("727") for _ in range(272)]
        prime = int("".join(digits))
        if isPrime(prime):
            return prime

# RSA encryption using the WYSI primes
# p = getWYSIprime()
# print(p)
# q = getWYSIprime()
# n = p * q
e = 65537
# flag = bytes_to_long(os.getenv("FLAG", b"osu{fake_flag_for_testing}"))
# ciphertext = pow(flag, e, n)
# print(f"{n = }")
# print(f"{e = }")
# print(f"{ciphertext = }")

n = 2160489795493918825870689458820648828073650907916827108594219132976202835249425984494778310568338106260399032800745421512005980632641226298431130513637640125399673697368934008374907832728004469350033174207285393191694692228748281256956917290437627249889472471749973975591415828107248775449619403563269856991145789325659736854030396401772371148983463743700921913930643887223704115714270634525795771407138067936125866995910432010323584269926871467482064993332990516534083898654487467161183876470821163254662352951613205371404232685831299594035879
e = 65537
ciphertext = 2087465275374927411696643073934443161977332564784688452208874207586196343901447373283939960111955963073429256266959192725814591103495590654238320816453299972810032321690243148092328690893438620034168359613530005646388116690482999620292746246472545500537029353066218068261278475470490922381998208396008297649151265515949490058859271855915806534872788601506545082508028917211992107642670108678400276555889198472686479168292281830557272701569298806067439923555717602352224216701010790924698838402522493324695403237985441044135894549709670322380450

mat = []
for i in range(2 ** 2):
    b = "{0:02b}".format(i)
    b = b.replace("0", "2").replace("1", '7')
    mat.append(int(b, 10))
arr = []
for i in mat:
    for j in mat:
        arr.append([i, j])
p = 27
q = 77
pq_arr = [[p, q]]
k = n
for i in range(2, 272, 2):
    new_arr = []
    for [p, q] in pq_arr:
        mod = 10 ** i
        assert (k - p * q) % mod == 0
        k_mod = (k - p * q) // mod % 100
        for j in arr:
            if (j[0] * q + j[1] * p) % 100 == k_mod:
                p1 = j[0] * mod + p
                q1 = j[1] * mod + q
                new_arr.append([p1, q1])
    pq_arr = new_arr
    # print(pq_arr)
    # if i >= 6:
    #     break

p, q = pq_arr[1]

phi = (p - 1) * (q - 1)
d = inverse(e, phi)

print(long_to_bytes(pow(ciphertext, d, n)))
